// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'test_submit_result.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

TestSubmitResult _$TestSubmitResultFromJson(Map<String, dynamic> json) {
  return _TestSubmitResult.fromJson(json);
}

/// @nodoc
mixin _$TestSubmitResult {
  int get testArchivedId => throw _privateConstructorUsedError;
  int get index => throw _privateConstructorUsedError;
  int? get id => throw _privateConstructorUsedError;
  int? get userId => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  int? get testId => throw _privateConstructorUsedError;
  int? get testVersion => throw _privateConstructorUsedError;
  double get score => throw _privateConstructorUsedError;
  int get top => throw _privateConstructorUsedError;
  double get totalRewardCoin => throw _privateConstructorUsedError;
  double get duration => throw _privateConstructorUsedError;
  int get totalRightAnswer => throw _privateConstructorUsedError;
  int get totalQuestions => throw _privateConstructorUsedError;
  int get totalUser => throw _privateConstructorUsedError;
  double? get rankingPoint => throw _privateConstructorUsedError;
  List<TestSubmitResultQuestion> get resultList =>
      throw _privateConstructorUsedError;
  Map<String, TestSubmitResultAnswerType> get result =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TestSubmitResultCopyWith<TestSubmitResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TestSubmitResultCopyWith<$Res> {
  factory $TestSubmitResultCopyWith(
          TestSubmitResult value, $Res Function(TestSubmitResult) then) =
      _$TestSubmitResultCopyWithImpl<$Res>;
  $Res call(
      {int testArchivedId,
      int index,
      int? id,
      int? userId,
      String? title,
      int? testId,
      int? testVersion,
      double score,
      int top,
      double totalRewardCoin,
      double duration,
      int totalRightAnswer,
      int totalQuestions,
      int totalUser,
      double? rankingPoint,
      List<TestSubmitResultQuestion> resultList,
      Map<String, TestSubmitResultAnswerType> result});
}

/// @nodoc
class _$TestSubmitResultCopyWithImpl<$Res>
    implements $TestSubmitResultCopyWith<$Res> {
  _$TestSubmitResultCopyWithImpl(this._value, this._then);

  final TestSubmitResult _value;
  // ignore: unused_field
  final $Res Function(TestSubmitResult) _then;

  @override
  $Res call({
    Object? testArchivedId = freezed,
    Object? index = freezed,
    Object? id = freezed,
    Object? userId = freezed,
    Object? title = freezed,
    Object? testId = freezed,
    Object? testVersion = freezed,
    Object? score = freezed,
    Object? top = freezed,
    Object? totalRewardCoin = freezed,
    Object? duration = freezed,
    Object? totalRightAnswer = freezed,
    Object? totalQuestions = freezed,
    Object? totalUser = freezed,
    Object? rankingPoint = freezed,
    Object? resultList = freezed,
    Object? result = freezed,
  }) {
    return _then(_value.copyWith(
      testArchivedId: testArchivedId == freezed
          ? _value.testArchivedId
          : testArchivedId // ignore: cast_nullable_to_non_nullable
              as int,
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      userId: userId == freezed
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as int?,
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      testId: testId == freezed
          ? _value.testId
          : testId // ignore: cast_nullable_to_non_nullable
              as int?,
      testVersion: testVersion == freezed
          ? _value.testVersion
          : testVersion // ignore: cast_nullable_to_non_nullable
              as int?,
      score: score == freezed
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      top: top == freezed
          ? _value.top
          : top // ignore: cast_nullable_to_non_nullable
              as int,
      totalRewardCoin: totalRewardCoin == freezed
          ? _value.totalRewardCoin
          : totalRewardCoin // ignore: cast_nullable_to_non_nullable
              as double,
      duration: duration == freezed
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as double,
      totalRightAnswer: totalRightAnswer == freezed
          ? _value.totalRightAnswer
          : totalRightAnswer // ignore: cast_nullable_to_non_nullable
              as int,
      totalQuestions: totalQuestions == freezed
          ? _value.totalQuestions
          : totalQuestions // ignore: cast_nullable_to_non_nullable
              as int,
      totalUser: totalUser == freezed
          ? _value.totalUser
          : totalUser // ignore: cast_nullable_to_non_nullable
              as int,
      rankingPoint: rankingPoint == freezed
          ? _value.rankingPoint
          : rankingPoint // ignore: cast_nullable_to_non_nullable
              as double?,
      resultList: resultList == freezed
          ? _value.resultList
          : resultList // ignore: cast_nullable_to_non_nullable
              as List<TestSubmitResultQuestion>,
      result: result == freezed
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as Map<String, TestSubmitResultAnswerType>,
    ));
  }
}

/// @nodoc
abstract class _$$_TestSubmitResultCopyWith<$Res>
    implements $TestSubmitResultCopyWith<$Res> {
  factory _$$_TestSubmitResultCopyWith(
          _$_TestSubmitResult value, $Res Function(_$_TestSubmitResult) then) =
      __$$_TestSubmitResultCopyWithImpl<$Res>;
  @override
  $Res call(
      {int testArchivedId,
      int index,
      int? id,
      int? userId,
      String? title,
      int? testId,
      int? testVersion,
      double score,
      int top,
      double totalRewardCoin,
      double duration,
      int totalRightAnswer,
      int totalQuestions,
      int totalUser,
      double? rankingPoint,
      List<TestSubmitResultQuestion> resultList,
      Map<String, TestSubmitResultAnswerType> result});
}

/// @nodoc
class __$$_TestSubmitResultCopyWithImpl<$Res>
    extends _$TestSubmitResultCopyWithImpl<$Res>
    implements _$$_TestSubmitResultCopyWith<$Res> {
  __$$_TestSubmitResultCopyWithImpl(
      _$_TestSubmitResult _value, $Res Function(_$_TestSubmitResult) _then)
      : super(_value, (v) => _then(v as _$_TestSubmitResult));

  @override
  _$_TestSubmitResult get _value => super._value as _$_TestSubmitResult;

  @override
  $Res call({
    Object? testArchivedId = freezed,
    Object? index = freezed,
    Object? id = freezed,
    Object? userId = freezed,
    Object? title = freezed,
    Object? testId = freezed,
    Object? testVersion = freezed,
    Object? score = freezed,
    Object? top = freezed,
    Object? totalRewardCoin = freezed,
    Object? duration = freezed,
    Object? totalRightAnswer = freezed,
    Object? totalQuestions = freezed,
    Object? totalUser = freezed,
    Object? rankingPoint = freezed,
    Object? resultList = freezed,
    Object? result = freezed,
  }) {
    return _then(_$_TestSubmitResult(
      testArchivedId: testArchivedId == freezed
          ? _value.testArchivedId
          : testArchivedId // ignore: cast_nullable_to_non_nullable
              as int,
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      userId: userId == freezed
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as int?,
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      testId: testId == freezed
          ? _value.testId
          : testId // ignore: cast_nullable_to_non_nullable
              as int?,
      testVersion: testVersion == freezed
          ? _value.testVersion
          : testVersion // ignore: cast_nullable_to_non_nullable
              as int?,
      score: score == freezed
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      top: top == freezed
          ? _value.top
          : top // ignore: cast_nullable_to_non_nullable
              as int,
      totalRewardCoin: totalRewardCoin == freezed
          ? _value.totalRewardCoin
          : totalRewardCoin // ignore: cast_nullable_to_non_nullable
              as double,
      duration: duration == freezed
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as double,
      totalRightAnswer: totalRightAnswer == freezed
          ? _value.totalRightAnswer
          : totalRightAnswer // ignore: cast_nullable_to_non_nullable
              as int,
      totalQuestions: totalQuestions == freezed
          ? _value.totalQuestions
          : totalQuestions // ignore: cast_nullable_to_non_nullable
              as int,
      totalUser: totalUser == freezed
          ? _value.totalUser
          : totalUser // ignore: cast_nullable_to_non_nullable
              as int,
      rankingPoint: rankingPoint == freezed
          ? _value.rankingPoint
          : rankingPoint // ignore: cast_nullable_to_non_nullable
              as double?,
      resultList: resultList == freezed
          ? _value._resultList
          : resultList // ignore: cast_nullable_to_non_nullable
              as List<TestSubmitResultQuestion>,
      result: result == freezed
          ? _value._result
          : result // ignore: cast_nullable_to_non_nullable
              as Map<String, TestSubmitResultAnswerType>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TestSubmitResult
    with DiagnosticableTreeMixin
    implements _TestSubmitResult {
  const _$_TestSubmitResult(
      {required this.testArchivedId,
      required this.index,
      this.id,
      this.userId,
      this.title,
      this.testId,
      this.testVersion,
      this.score = 0,
      this.top = 0,
      this.totalRewardCoin = 0,
      this.duration = 0,
      this.totalRightAnswer = 0,
      this.totalQuestions = 0,
      this.totalUser = 1,
      this.rankingPoint,
      final List<TestSubmitResultQuestion> resultList = const [],
      required final Map<String, TestSubmitResultAnswerType> result})
      : _resultList = resultList,
        _result = result;

  factory _$_TestSubmitResult.fromJson(Map<String, dynamic> json) =>
      _$$_TestSubmitResultFromJson(json);

  @override
  final int testArchivedId;
  @override
  final int index;
  @override
  final int? id;
  @override
  final int? userId;
  @override
  final String? title;
  @override
  final int? testId;
  @override
  final int? testVersion;
  @override
  @JsonKey()
  final double score;
  @override
  @JsonKey()
  final int top;
  @override
  @JsonKey()
  final double totalRewardCoin;
  @override
  @JsonKey()
  final double duration;
  @override
  @JsonKey()
  final int totalRightAnswer;
  @override
  @JsonKey()
  final int totalQuestions;
  @override
  @JsonKey()
  final int totalUser;
  @override
  final double? rankingPoint;
  final List<TestSubmitResultQuestion> _resultList;
  @override
  @JsonKey()
  List<TestSubmitResultQuestion> get resultList {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_resultList);
  }

  final Map<String, TestSubmitResultAnswerType> _result;
  @override
  Map<String, TestSubmitResultAnswerType> get result {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_result);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TestSubmitResult(testArchivedId: $testArchivedId, index: $index, id: $id, userId: $userId, title: $title, testId: $testId, testVersion: $testVersion, score: $score, top: $top, totalRewardCoin: $totalRewardCoin, duration: $duration, totalRightAnswer: $totalRightAnswer, totalQuestions: $totalQuestions, totalUser: $totalUser, rankingPoint: $rankingPoint, resultList: $resultList, result: $result)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TestSubmitResult'))
      ..add(DiagnosticsProperty('testArchivedId', testArchivedId))
      ..add(DiagnosticsProperty('index', index))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('userId', userId))
      ..add(DiagnosticsProperty('title', title))
      ..add(DiagnosticsProperty('testId', testId))
      ..add(DiagnosticsProperty('testVersion', testVersion))
      ..add(DiagnosticsProperty('score', score))
      ..add(DiagnosticsProperty('top', top))
      ..add(DiagnosticsProperty('totalRewardCoin', totalRewardCoin))
      ..add(DiagnosticsProperty('duration', duration))
      ..add(DiagnosticsProperty('totalRightAnswer', totalRightAnswer))
      ..add(DiagnosticsProperty('totalQuestions', totalQuestions))
      ..add(DiagnosticsProperty('totalUser', totalUser))
      ..add(DiagnosticsProperty('rankingPoint', rankingPoint))
      ..add(DiagnosticsProperty('resultList', resultList))
      ..add(DiagnosticsProperty('result', result));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TestSubmitResult &&
            const DeepCollectionEquality()
                .equals(other.testArchivedId, testArchivedId) &&
            const DeepCollectionEquality().equals(other.index, index) &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.userId, userId) &&
            const DeepCollectionEquality().equals(other.title, title) &&
            const DeepCollectionEquality().equals(other.testId, testId) &&
            const DeepCollectionEquality()
                .equals(other.testVersion, testVersion) &&
            const DeepCollectionEquality().equals(other.score, score) &&
            const DeepCollectionEquality().equals(other.top, top) &&
            const DeepCollectionEquality()
                .equals(other.totalRewardCoin, totalRewardCoin) &&
            const DeepCollectionEquality().equals(other.duration, duration) &&
            const DeepCollectionEquality()
                .equals(other.totalRightAnswer, totalRightAnswer) &&
            const DeepCollectionEquality()
                .equals(other.totalQuestions, totalQuestions) &&
            const DeepCollectionEquality().equals(other.totalUser, totalUser) &&
            const DeepCollectionEquality()
                .equals(other.rankingPoint, rankingPoint) &&
            const DeepCollectionEquality()
                .equals(other._resultList, _resultList) &&
            const DeepCollectionEquality().equals(other._result, _result));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(testArchivedId),
      const DeepCollectionEquality().hash(index),
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(userId),
      const DeepCollectionEquality().hash(title),
      const DeepCollectionEquality().hash(testId),
      const DeepCollectionEquality().hash(testVersion),
      const DeepCollectionEquality().hash(score),
      const DeepCollectionEquality().hash(top),
      const DeepCollectionEquality().hash(totalRewardCoin),
      const DeepCollectionEquality().hash(duration),
      const DeepCollectionEquality().hash(totalRightAnswer),
      const DeepCollectionEquality().hash(totalQuestions),
      const DeepCollectionEquality().hash(totalUser),
      const DeepCollectionEquality().hash(rankingPoint),
      const DeepCollectionEquality().hash(_resultList),
      const DeepCollectionEquality().hash(_result));

  @JsonKey(ignore: true)
  @override
  _$$_TestSubmitResultCopyWith<_$_TestSubmitResult> get copyWith =>
      __$$_TestSubmitResultCopyWithImpl<_$_TestSubmitResult>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TestSubmitResultToJson(
      this,
    );
  }
}

abstract class _TestSubmitResult implements TestSubmitResult {
  const factory _TestSubmitResult(
          {required final int testArchivedId,
          required final int index,
          final int? id,
          final int? userId,
          final String? title,
          final int? testId,
          final int? testVersion,
          final double score,
          final int top,
          final double totalRewardCoin,
          final double duration,
          final int totalRightAnswer,
          final int totalQuestions,
          final int totalUser,
          final double? rankingPoint,
          final List<TestSubmitResultQuestion> resultList,
          required final Map<String, TestSubmitResultAnswerType> result}) =
      _$_TestSubmitResult;

  factory _TestSubmitResult.fromJson(Map<String, dynamic> json) =
      _$_TestSubmitResult.fromJson;

  @override
  int get testArchivedId;
  @override
  int get index;
  @override
  int? get id;
  @override
  int? get userId;
  @override
  String? get title;
  @override
  int? get testId;
  @override
  int? get testVersion;
  @override
  double get score;
  @override
  int get top;
  @override
  double get totalRewardCoin;
  @override
  double get duration;
  @override
  int get totalRightAnswer;
  @override
  int get totalQuestions;
  @override
  int get totalUser;
  @override
  double? get rankingPoint;
  @override
  List<TestSubmitResultQuestion> get resultList;
  @override
  Map<String, TestSubmitResultAnswerType> get result;
  @override
  @JsonKey(ignore: true)
  _$$_TestSubmitResultCopyWith<_$_TestSubmitResult> get copyWith =>
      throw _privateConstructorUsedError;
}

TestSubmitResultQuestion _$TestSubmitResultQuestionFromJson(
    Map<String, dynamic> json) {
  return _TestSubmitResultQuestion.fromJson(json);
}

/// @nodoc
mixin _$TestSubmitResultQuestion {
  AnswerResultEnum get state => throw _privateConstructorUsedError;
  TestQuestionType get question => throw _privateConstructorUsedError;
  List<String> get selectedAnswers => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TestSubmitResultQuestionCopyWith<TestSubmitResultQuestion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TestSubmitResultQuestionCopyWith<$Res> {
  factory $TestSubmitResultQuestionCopyWith(TestSubmitResultQuestion value,
          $Res Function(TestSubmitResultQuestion) then) =
      _$TestSubmitResultQuestionCopyWithImpl<$Res>;
  $Res call(
      {AnswerResultEnum state,
      TestQuestionType question,
      List<String> selectedAnswers});

  $TestQuestionTypeCopyWith<$Res> get question;
}

/// @nodoc
class _$TestSubmitResultQuestionCopyWithImpl<$Res>
    implements $TestSubmitResultQuestionCopyWith<$Res> {
  _$TestSubmitResultQuestionCopyWithImpl(this._value, this._then);

  final TestSubmitResultQuestion _value;
  // ignore: unused_field
  final $Res Function(TestSubmitResultQuestion) _then;

  @override
  $Res call({
    Object? state = freezed,
    Object? question = freezed,
    Object? selectedAnswers = freezed,
  }) {
    return _then(_value.copyWith(
      state: state == freezed
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as AnswerResultEnum,
      question: question == freezed
          ? _value.question
          : question // ignore: cast_nullable_to_non_nullable
              as TestQuestionType,
      selectedAnswers: selectedAnswers == freezed
          ? _value.selectedAnswers
          : selectedAnswers // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }

  @override
  $TestQuestionTypeCopyWith<$Res> get question {
    return $TestQuestionTypeCopyWith<$Res>(_value.question, (value) {
      return _then(_value.copyWith(question: value));
    });
  }
}

/// @nodoc
abstract class _$$_TestSubmitResultQuestionCopyWith<$Res>
    implements $TestSubmitResultQuestionCopyWith<$Res> {
  factory _$$_TestSubmitResultQuestionCopyWith(
          _$_TestSubmitResultQuestion value,
          $Res Function(_$_TestSubmitResultQuestion) then) =
      __$$_TestSubmitResultQuestionCopyWithImpl<$Res>;
  @override
  $Res call(
      {AnswerResultEnum state,
      TestQuestionType question,
      List<String> selectedAnswers});

  @override
  $TestQuestionTypeCopyWith<$Res> get question;
}

/// @nodoc
class __$$_TestSubmitResultQuestionCopyWithImpl<$Res>
    extends _$TestSubmitResultQuestionCopyWithImpl<$Res>
    implements _$$_TestSubmitResultQuestionCopyWith<$Res> {
  __$$_TestSubmitResultQuestionCopyWithImpl(_$_TestSubmitResultQuestion _value,
      $Res Function(_$_TestSubmitResultQuestion) _then)
      : super(_value, (v) => _then(v as _$_TestSubmitResultQuestion));

  @override
  _$_TestSubmitResultQuestion get _value =>
      super._value as _$_TestSubmitResultQuestion;

  @override
  $Res call({
    Object? state = freezed,
    Object? question = freezed,
    Object? selectedAnswers = freezed,
  }) {
    return _then(_$_TestSubmitResultQuestion(
      state: state == freezed
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as AnswerResultEnum,
      question: question == freezed
          ? _value.question
          : question // ignore: cast_nullable_to_non_nullable
              as TestQuestionType,
      selectedAnswers: selectedAnswers == freezed
          ? _value._selectedAnswers
          : selectedAnswers // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TestSubmitResultQuestion
    with DiagnosticableTreeMixin
    implements _TestSubmitResultQuestion {
  const _$_TestSubmitResultQuestion(
      {this.state = AnswerResultEnum.notanswer,
      required this.question,
      final List<String> selectedAnswers = const []})
      : _selectedAnswers = selectedAnswers;

  factory _$_TestSubmitResultQuestion.fromJson(Map<String, dynamic> json) =>
      _$$_TestSubmitResultQuestionFromJson(json);

  @override
  @JsonKey()
  final AnswerResultEnum state;
  @override
  final TestQuestionType question;
  final List<String> _selectedAnswers;
  @override
  @JsonKey()
  List<String> get selectedAnswers {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_selectedAnswers);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TestSubmitResultQuestion(state: $state, question: $question, selectedAnswers: $selectedAnswers)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TestSubmitResultQuestion'))
      ..add(DiagnosticsProperty('state', state))
      ..add(DiagnosticsProperty('question', question))
      ..add(DiagnosticsProperty('selectedAnswers', selectedAnswers));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TestSubmitResultQuestion &&
            const DeepCollectionEquality().equals(other.state, state) &&
            const DeepCollectionEquality().equals(other.question, question) &&
            const DeepCollectionEquality()
                .equals(other._selectedAnswers, _selectedAnswers));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(state),
      const DeepCollectionEquality().hash(question),
      const DeepCollectionEquality().hash(_selectedAnswers));

  @JsonKey(ignore: true)
  @override
  _$$_TestSubmitResultQuestionCopyWith<_$_TestSubmitResultQuestion>
      get copyWith => __$$_TestSubmitResultQuestionCopyWithImpl<
          _$_TestSubmitResultQuestion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TestSubmitResultQuestionToJson(
      this,
    );
  }
}

abstract class _TestSubmitResultQuestion implements TestSubmitResultQuestion {
  const factory _TestSubmitResultQuestion(
      {final AnswerResultEnum state,
      required final TestQuestionType question,
      final List<String> selectedAnswers}) = _$_TestSubmitResultQuestion;

  factory _TestSubmitResultQuestion.fromJson(Map<String, dynamic> json) =
      _$_TestSubmitResultQuestion.fromJson;

  @override
  AnswerResultEnum get state;
  @override
  TestQuestionType get question;
  @override
  List<String> get selectedAnswers;
  @override
  @JsonKey(ignore: true)
  _$$_TestSubmitResultQuestionCopyWith<_$_TestSubmitResultQuestion>
      get copyWith => throw _privateConstructorUsedError;
}
